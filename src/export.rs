use crate::tables::{self, SurfaceTable, VolumeTable};
use std::fmt::Write;
use std::path::Path;

pub fn export_tables(
    surf_table: &SurfaceTable,
    volume_table: &VolumeTable,
    path: &Path,
) -> Result<(), String> {
    std::fs::write(
        path,
        match path.extension().map(|e| e.to_str()).flatten() {
            Some("cpp" | "c" | "h" | "hpp") => cpp_tables(surf_table, volume_table),
            _ => {
                return Err("Unrecognized language / file extension".to_string());
            }
        }
        .map_err(|e| format!("{e}"))?,
    )
    .map_err(|e| format!("{e}"))
}

fn cpp_tables(
    surf_table: &SurfaceTable,
    volume_table: &VolumeTable,
) -> Result<String, std::fmt::Error> {
    let mut out = String::new();
    writeln!(
        out,
        r#"
/// This code contains look up tables for slicing tets with surfaces. This was auto generated by tetable.
/// Tetable can be found at: https://github.com/ranjeethmahankali/tetable

#include <array>
#include <cassert>
#include <cstdint>

"#
    )?;
    writeln!(out, "namespace tetable {{\n")?; // begin namespace.
    {
        // Surface - indices.
        let indices = surf_table.indices();
        writeln!(
            out,
            "static constexpr std::array<uint8_t, {}> SURF_INDICES {{{{",
            indices.len()
        )?;
        for chunk in indices.chunks(24) {
            write!(out, "\t")?;
            for i in chunk {
                write!(out, "{}, ", i)?;
            }
            writeln!(out, "")?;
        }
        writeln!(out, "}}}};\n")?; // end array.
        // Ranges.
        let ranges = surf_table.ranges();
        writeln!(
            out,
            "\nstatic constexpr std::array<std::pair<size_t, size_t>, {}> SURF_LOOKUP {{{{",
            ranges.len()
        )?;
        for chunk in ranges.chunks(8) {
            write!(out, "\t")?;
            for (start, len) in chunk {
                write!(out, "{{{start}, {len}}}, ")?;
            }
            writeln!(out, "")?;
        }
        writeln!(out, "}}}};\n")?; // end array.
    }
    {
        // Volume - indices.
        let indices = volume_table.indices();
        writeln!(
            out,
            "static constexpr std::array<uint8_t, {}> VOLUME_INDICES {{{{",
            indices.len()
        )?;
        for chunk in indices.chunks(24) {
            write!(out, "\t")?;
            for i in chunk {
                write!(out, "{}, ", i)?;
            }
            writeln!(out, "")?;
        }
        writeln!(out, "}}}};\n")?; // end array.
        // ranges.
        let ranges = volume_table.ranges();
        writeln!(
            out,
            "\nstatic constexpr std::array<std::array<std::pair<size_t, size_t>, {}>, {}> VOLUME_LOOKUP {{{{",
            tables::NUM_IDX_PERM,
            tables::NUM_MASK_COMB
        )?;
        for ranges in ranges {
            writeln!(out, "\t{{{{")?; // open inner array.
            for chunk in ranges.chunks(8) {
                write!(out, "\t\t")?;
                for (start, len) in chunk {
                    write!(out, "{{{start}, {len}}}, ")?;
                }
                writeln!(out, "")?;
            }
            writeln!(out, "\t}}}},")?; // close inner array.
        }
        writeln!(out, "}}}};\n")?; // end array.
    }
    {
        // Helper functions.
        writeln!(
            out,
            r#"
/**
 * @brief Given the states of the tet vertices relative to the slicing surface, this function returns the indices of the
 * triangulation.
 *
 * Each of the 4 vertices can have 3 states: 0 for when it is inside the slicing surface, 1 for when it is exactly on the slicing
 * surface, and 2 for when it is outside the surface. The vertices of the tet, locally, are expected to be arraynged such that the
 * normal of the triangle formed by the first three vertices (oriented) points toward the fourth vertex.
 *
 * The indices returned by the output can be read three at a time, as the indices of the triangles approximating the slicing
 * surface. The indices can range from 0 to 9. Indices 0, 1, 2, 3 refer to the original tet vertices. The remaining indices refer
 * to the crossing points on the tet edges as follows:
 *
 * 4 => crossing point on the edge joining vertices 0 and 1
 * 5 => crossing point on the edge joining vertices 0 and 2
 * 6 => crossing point on the edge joining vertices 0 and 3
 * 7 => crossing point on the edge joining vertices 1 and 2
 * 8 => crossing point on the edge joining vertices 1 and 3
 * 9 => crossing point on the edge joining vertices 2 and 3
 *
 * @param vstates Array containing the states of the 4 vertices.
 */
std::pair<uint8_t const*, size_t> surface_lookup(std::array<uint8_t, 4> const& vstates)
{{
    uint8_t mask = 0;
    // Each vertex has 3 possible states, so we compute a base three integer value.
    for (auto it = vstates.rbegin(); it != vstates.rend(); ++it) {{
        uint8_t const s = *it;
        assert(s < 3);
        mask *= 3;
        mask += s;
    }}
    assert(mask < 81);
    // This range gives the start index, and the number of indices to read after.
    std::pair<size_t, size_t> const& range = SURF_LOOKUP[mask];
    return std::make_pair(SURF_INDICES.data() + range.first, range.second);
}}

/**
 * @brief Given the states of the tet vertices relative to the slicing surface, and the global indices of the tet vertices (listed
 * in the local order of the vertices), this function returns the indices of the tetrahedralization of the tet, after it is sliced
 * by the surface.
 *
 * Each of the 4 vertices can have 3 states: 0 for when it is inside the slicing surface, 1 for when it is exactly on the slicing
 * surface, and 2 for when it is outside the surface. The vertices of the tet, locally, are expected to be arraynged such that the
 * normal of the triangle formed by the first three vertices (oriented) points toward the fourth vertex.
 *
 * The global indices of the vertices is used to ensure the tetrahedralization of this tet is compatible with that of the
 * neighboring tet.
 *
 * @param vstates Array containing the states of the 4 vertices.
 * @param vindices Array containing the global indices of the 4 vertices.
 */
std::pair<uint8_t const*, size_t> volume_lookup(std::array<uint8_t, 4> const& vstates, std::array<size_t, 4> const& vindices)
{{
    uint8_t mask = 0;
    // Each vertex has 3 possible states, so we compute a base three integer value.
    for (auto it = vstates.rbegin(); it != vstates.rend(); ++it) {{
        uint8_t const s = *it;
        assert(s < 3);
        mask *= 3;
        mask += s;
    }}
    assert(mask < 81);
    // Compute the Lehmer rank of the vertex index permutation.
    static constexpr std::array<uint8_t, 4> LEHMER_COEFF {{{{6, 2, 1, 0}}}};
    uint8_t                                 rank = 0;
    for (size_t i = 0; i < 4; ++i) {{
        uint8_t count = 0;
        for (size_t j = i + 1; j < 4; ++j) {{
            assert(vindices[j] != vindices[i]);
            if (vindices[i] > vindices[j]) {{
                ++count;
            }}
        }}
        rank += count * LEHMER_COEFF[i];
    }}
    assert(mask < 81);
    assert(rank < 24);
    // This range gives the start index, and the number of indices to read after.
    std::pair<size_t, size_t> const& range = VOLUME_LOOKUP[mask][rank];
    return std::make_pair(VOLUME_INDICES.data() + range.first, range.second);
}}
"#
        )?;
    }
    writeln!(out, "}}")?; // end namespace.
    Ok(out)
}
